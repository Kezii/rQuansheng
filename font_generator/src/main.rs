use core::convert::Infallible;
use std::{env, fs, path::PathBuf};

use embedded_graphics::{
    Drawable,
    draw_target::DrawTarget,
    geometry::{OriginDimensions, Size},
    pixelcolor::BinaryColor,
    prelude::{Pixel, Point},
    text::{Baseline, Text},
};

/// Simple 1bpp framebuffer, packed MSB-first, row-major, byte-aligned per row.
struct Framebuffer1bpp {
    size: Size,
    data: Vec<u8>,
}

impl Framebuffer1bpp {
    fn new(size: Size) -> Self {
        let bpr = (size.width as usize).div_ceil(8);
        Self {
            size,
            data: vec![0u8; bpr * (size.height as usize)],
        }
    }

    fn bytes_per_row(&self) -> usize {
        (self.size.width as usize).div_ceil(8)
    }

    fn set_pixel(&mut self, p: Point, on: bool) {
        if p.x < 0 || p.y < 0 {
            return;
        }
        let (x, y) = (p.x as u32, p.y as u32);
        if x >= self.size.width || y >= self.size.height {
            return;
        }

        let bpr = self.bytes_per_row();
        let idx = (y as usize) * bpr + (x as usize) / 8;
        let bit = 7 - ((x as usize) & 7);
        if on {
            self.data[idx] |= 1u8 << bit;
        } else {
            self.data[idx] &= !(1u8 << bit);
        }
    }
}

impl OriginDimensions for Framebuffer1bpp {
    fn size(&self) -> Size {
        self.size
    }
}

impl DrawTarget for Framebuffer1bpp {
    type Color = BinaryColor;
    type Error = Infallible;

    fn draw_iter<I>(&mut self, pixels: I) -> Result<(), Self::Error>
    where
        I: IntoIterator<Item = Pixel<Self::Color>>,
    {
        for Pixel(p, c) in pixels {
            self.set_pixel(p, c.is_on());
        }
        Ok(())
    }
}

#[derive(Clone, Copy)]
struct FontJob {
    /// Name of the generated `MonoFont` const.
    font_const: &'static str,
    /// `StrGlyphMapping` data: literal list of glyphs in image order.
    ///
    /// you write exactly the glyphs you want to keep in flash, in the order you want.
    /// the first glyph is the replacement index.
    mapping_data: &'static str,

    /// The source font used for host-side rendering.
    source_font: &'static embedded_graphics::mono_font::MonoFont<'static>,
}

// NOTE: add new jobs here. Everything else below is generic.
const JOBS: &[FontJob] = &[
    FontJob {
        font_const: "PROFONT_24_POINT",
        mapping_data: "0123456789",
        source_font: &profont::PROFONT_24_POINT,
    },
    FontJob {
        font_const: "PROFONT_14_POINT",
        mapping_data: "0123456789",
        source_font: &profont::PROFONT_14_POINT,
    },
    FontJob {
        font_const: "PROFONT_10_POINT",
        mapping_data: "0123456789%",
        source_font: &profont::PROFONT_10_POINT,
    },
];

fn parse_args() -> (PathBuf, Option<PathBuf>) {
    // Usage:
    //   cargo run -p font_generator -- <out_rs> [out_raw_dir]
    let mut it = env::args().skip(1);
    let out_rs = it
        .next()
        .map(PathBuf::from)
        .unwrap_or_else(|| PathBuf::from("../cross/rquansheng/src/fonts_generated.rs"));
    let out_raw_dir = it.next().map(PathBuf::from);
    (out_rs, out_raw_dir)
}

fn rust_string_literal(s: &str) -> String {
    let mut out = String::new();
    out.push('"');
    for c in s.chars() {
        match c {
            '\\' => out.push_str("\\\\"),
            '"' => out.push_str("\\\""),
            '\n' => out.push_str("\\n"),
            '\r' => out.push_str("\\r"),
            '\t' => out.push_str("\\t"),
            '\0' => out.push_str("\\u{0000}"),
            c if c.is_ascii() && (c == ' ' || c.is_ascii_graphic()) => out.push(c),
            c => out.push_str(&format!("\\u{{{:X}}}", c as u32)),
        }
    }
    out.push('"');
    out
}

fn sanitize_filename_component(s: &str) -> String {
    // Stable-ish, simple, avoids platform-specific surprises.
    let mut out = String::new();
    for c in s.chars() {
        if c.is_ascii_alphanumeric() || c == '_' || c == '-' {
            out.push(c);
        } else {
            out.push('_');
        }
    }
    if out.is_empty() {
        out.push_str("font");
    }
    out
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let (out_rs, out_raw_dir) = parse_args();

    // Generate a .rs file that can be committed (contains *all* fonts in `JOBS`).
    if let Some(parent) = out_rs.parent() {
        fs::create_dir_all(parent)?;
    }

    let mut rs = String::new();
    rs.push_str("// @generated by font_generator\n");
    rs.push_str("// Generated by rendering source MonoFont(s) via embedded-graphics.\n");
    rs.push_str("// NOTE: edit `font_generator/src/main.rs` (JOBS) and re-run the generator.\n\n");
    rs.push_str("use embedded_graphics::{\n");
    rs.push_str("    geometry::Size,\n");
    rs.push_str("    image::ImageRaw,\n");
    rs.push_str("    mono_font::{mapping::StrGlyphMapping, DecorationDimensions, MonoFont},\n");
    rs.push_str("};\n\n");

    // Optional raw output (exact bytes used by ImageRaw<BinaryColor>), written per job.
    if let Some(out_raw_dir) = &out_raw_dir {
        fs::create_dir_all(out_raw_dir)?;
    }

    for job in JOBS {
        let alphabet = job.mapping_data.to_string();
        let glyph_count = alphabet.chars().count() as u32;
        let raw_const = format!("{}_RAW", job.font_const);
        let mapping_const = format!("{}_MAPPING", job.font_const);

        // Output metrics are taken exactly from the source font.
        let glyph_w = job.source_font.character_size.width;
        let glyph_h = job.source_font.character_size.height;
        let glyph_w_i32 = glyph_w as i32;
        let fb_w = glyph_w * glyph_count;
        let fb_h = glyph_h;

        let mut fb = Framebuffer1bpp::new(Size::new(fb_w, fb_h));

        let character_style =
            embedded_graphics::mono_font::MonoTextStyle::new(job.source_font, BinaryColor::On);

        // Draw each glyph at a fixed stride, independent of source font spacing.
        for (i, ch) in alphabet.chars().enumerate() {
            let mut tmp = [0u8; 4];
            let s = ch.encode_utf8(&mut tmp);
            let pos = Point::new((i as i32) * glyph_w_i32, 0);
            Text::with_baseline(s, pos, character_style, Baseline::Top).draw(&mut fb)?;
        }

        if let Some(out_raw_dir) = &out_raw_dir {
            let fname = format!("{}.bin", sanitize_filename_component(job.font_const));
            let out_raw = out_raw_dir.join(fname);
            fs::write(&out_raw, &fb.data)?;
            eprintln!("wrote raw: {} ({} bytes)", out_raw.display(), fb.data.len());
        }

        // Mapping const
        rs.push_str(&format!(
            "const {}: StrGlyphMapping = StrGlyphMapping::new({}, {});\n\n",
            mapping_const,
            rust_string_literal(job.mapping_data),
            0 // replacement index is just the first glyph
        ));

        // Raw bytes const
        rs.push_str(&format!(
            "pub const {}: [u8; {}] = [\n",
            raw_const,
            fb.data.len()
        ));

        for (i, b) in fb.data.iter().enumerate() {
            if i % 12 == 0 {
                rs.push_str("    ");
            }
            rs.push_str(&format!("0x{b:02X}, "));
            if i % 12 == 11 {
                rs.push('\n');
            }
        }
        if !fb.data.len().is_multiple_of(12) {
            rs.push('\n');
        }
        rs.push_str("];\n\n");

        // MonoFont const
        rs.push_str(&format!(
            "pub const {}: MonoFont = MonoFont {{\n",
            job.font_const
        ));
        rs.push_str(&format!(
            "    image: ImageRaw::new(&{}, {} * {}),\n",
            raw_const, glyph_count, glyph_w
        ));
        rs.push_str(&format!(
            "    character_size: Size::new({}, {}),\n",
            glyph_w, glyph_h
        ));
        rs.push_str(&format!(
            "    character_spacing: {},\n",
            job.source_font.character_spacing
        ));
        rs.push_str(&format!("    baseline: {},\n", job.source_font.baseline));
        rs.push_str(&format!(
            "    underline: DecorationDimensions::new({}, {}),\n",
            job.source_font.underline.offset, job.source_font.underline.height
        ));
        rs.push_str(&format!(
            "    strikethrough: DecorationDimensions::new({}, {}),\n",
            job.source_font.strikethrough.offset, job.source_font.strikethrough.height
        ));
        rs.push_str(&format!("    glyph_mapping: &{},\n", mapping_const));
        rs.push_str("};\n\n");
    }

    fs::write(&out_rs, rs)?;
    eprintln!("wrote rs: {}", out_rs.display());

    Ok(())
}
